- Class: meta
  Course: R Programming
  Lesson: Simulation
  Author: Nick Carchedi
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: Einer der großen Vorteile der Verwendung von statistischen Programmiersprachen wie R ist die Vielzahl an Möglichkeiten, Zufallszahlen zu simulieren.

- Class: cmd_question
  Output: Die erste Funktion, die wir benutzen werden um Zufallszahlen zu generieren, ist sample(). Nutzen Sie den Befehl ?sample, um die Dokumentation aufzurufen.
  CorrectAnswer: ?sample
  AnswerTests: omnitest(correctExpr='?sample')
  Hint: Nutzen Sie den Befehl '?sample', um die Dokumentation für die Funktion sample() aufzurufen. 

- Class: cmd_question
  Output: "Wir wollen nun einen viermaligen Würfelwurf mit der Funktion sample(1:6, 4, replace = TRUE) simulieren. Probieren Sie dies jetzt aus."
  CorrectAnswer: sample(1:6, 4, replace = TRUE)
  AnswerTests: match_call('sample(1:6, 4, replace = TRUE)')
  Hint: Tippen Sie sample(1:6, 4, replace = TRUE) in die Konsole, um einen viermaligen Würfelwurf zu simulieren.

- Class: cmd_question
  Output: "Wiederholen Sie nun den Befehl, um zu sehen, wie sich das neue Ergebnis vom vorherigen unterscheidet (Die Wahrscheinlichkeit für exakt dasselbe Ergebnis ist extrem gering: (1/6)^4 = 0.00077 = 0.077%)."
  CorrectAnswer: sample(1:6, 4, replace = TRUE)
  AnswerTests: match_call('sample(1:6, 4, replace = TRUE)')
  Hint: Tippen Sie sample(1:6, 4, replace = TRUE) in die Konsole, um einen viermaligen Würfelwurf zu simulieren.

- Class: text
  Output: 'Der Befehl sample(1:6, 4, replace = TRUE) lässt R zufällig vier Zahlen zwischen 1 und 6 ziehen. "replace = TRUE" steht für das Ziehen MIT Zurücklegen. Jedes Element, das gezogen wurde, wird wieder "zurückgelegt", sodass dieselbe Zahl mehr als einmal vorkommen kann. Genau das wollen wir hier, da bei jedem Würfelwurf alle Zahlen zwischen 1 und 6 gewürfelt werden können, unabhängig davon, welche Zahl beim ersten Mal gewürfelt wurde.'

- Class: cmd_question
  Output: 'Lassen Sie R nun 10 Zahlen zwischen 1 und 20 OHNE Zurücklegen ziehen. Wenn Sie das Argument "replace" weglassen, zieht R automatisch ohne Zurücklegen.'
  CorrectAnswer: sample(1:20, 10)
  AnswerTests: match_call('sample(1:20, 10)')
  Hint: Tippen Sie sample(1:20, 10) in die Konsole, um zufällig und ohne Zurücklegen 10 Zahlen zwischen 1 und 20 zu ziehen.

- Class: text
  Output: Da wir R befohlen haben, ohne Zurücklegen zu ziehen, kommt im Output keine Zahl mehr als einmal vor.

- Class: cmd_question
  Output: LETTERS ist eine vordefinierte Variable in R, die einen Vektor mit allen 26 Buchstaben des englischen Alphabets enthält. Schauen Sie sich die Variable jetzt an.
  AnswerTests: omnitest(correctExpr='LETTERS')
  Hint: Tippen Sie LETTERS, um den Inhalt der Variablen in der Konsole zu sehen.

- Class: cmd_question
  Output: Die Funktion sample() kann auch genutzt werden, um die Elemente eines Vektors zu permutieren bzw. neu anzuordnen. Lassen Sie R mit sample(LETTERS) alle 26 Buchstaben des englischen Alphabets neu anordnen.
  CorrectAnswer: sample(LETTERS)
  AnswerTests: omnitest(correctExpr='sample(LETTERS)')
  Hint: Tippen Sie sample(LETTERS), um alle 26 Buchstaben des englischen Alphabets neu anzuordnen.

- Class: text
  Output: Dies ist dasselbe, wie eine Stichprobe der Größe 26 aus der Menge LETTERS (ohne Zurücklegen)zu ziehen. Wenn das Argument 'size' der Funktion sample() nicht spezifiziert wird, zieht R eine Stichprobe von der Größe des Vektors, aus dem gezogen wird.

- Class: text
  Output: Now, suppose we want to simulate 100 flips of an unfair two-sided coin. This particular coin has a 0.3 probability of landing 'tails' and a 0.7 probability of landing 'heads'.

- Class: cmd_question
  Output: Let the value 0 represent tails and the value 1 represent heads. Use sample() to draw a sample of size 100 from the vector c(0,1), with replacement. Since the coin is unfair, we must attach specific probabilities to the values 0 (tails) and 1 (heads) with a fourth argument, prob = c(0.3, 0.7). Assign the result to a new variable called flips.
  CorrectAnswer: flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))
  AnswerTests: match_call('flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))')
  Hint: 'The following command will produce 100 flips of an unfair coin and assign the result: flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))'

- Class: cmd_question
  Output: View the contents of the flips variable.
  CorrectAnswer: flips
  AnswerTests: omnitest(correctExpr='flips')
  Hint: Just type flips to view its contents.

- Class: cmd_question
  Output: Since we set the probability of landing heads on any given flip to be 0.7, we'd expect approximately 70 of our coin flips to have the value 1. Count the actual number of 1s contained in flips using the sum() function.
  CorrectAnswer: sum(flips)
  AnswerTests: omnitest(correctExpr='sum(flips)')
  Hint: sum(flips) will add up all the 1s and 0s, giving you the total number of 1s in flips.

- Class: cmd_question
  Output: A coin flip is a binary outcome (0 or 1) and we are performing 100 independent trials (coin flips), so we can use use rbinom() to simulate a binomial random variable. Pull up the documentation for rbinom() using ?rbinom.
  CorrectAnswer: ?rbinom
  AnswerTests: omnitest(correctExpr='?rbinom')
  Hint: Type ?rbinom to pull up the help file for rbinom().

- Class: text
  Output: Each probability distribution in R has an r*** function (for "random"), a d*** function (for "density"), a p*** (for "probability"), and q*** (for "quantile"). We are most interested in the r*** functions in this lesson, but I encourage you to explore the others on your own.

- Class: cmd_question
  Output: A binomial random variable represents the number of 'successes' (heads) in a given number of independent 'trials' (coin flips). Therefore, we can generate a single random variable that represents the number of heads in 100 flips of our unfair coin using rbinom(1, size = 100, prob = 0.7). Note that you only specify the probability of 'success' (heads) and NOT the probability of 'failure' (tails). Try it now.
  CorrectAnswer: rbinom(1, size = 100, prob = 0.7)
  AnswerTests: match_call('rbinom(1, size = 100, prob = 0.7)')
  Hint: Call rbinom() with n = 1, size = 100, and prob = 0.7.

- Class: cmd_question
  Output: Equivalently, if we want to see all of the 0s and 1s, we can request 100 observations, each of size 1, with success probability of 0.7. Give it a try, assigning the result to a new variable called flips2.
  CorrectAnswer: flips2 <- rbinom(100, size = 1, prob = 0.7)
  AnswerTests: match_call('flips2 <- rbinom(100, size = 1, prob = 0.7)')
  Hint: Call rbinom() with n = 100, size = 1, and prob = 0.7 and assign the result to flips2.

- Class: cmd_question
  Output: View the contents of flips2.
  CorrectAnswer: flips2
  AnswerTests: omnitest('flips2')
  Hint: Type flips2 to view its contents.

- Class: cmd_question
  Output: Now use sum() to count the number of 1s (heads) in flips2. It should be close to 70!
  CorrectAnswer: sum(flips2)
  AnswerTests: omnitest('sum(flips2)')
  Hint: Use sum(flips2) to count the number of 1s.

- Class: cmd_question
  Output: Similar to rbinom(), we can use R to simulate random numbers from many other probability distributions. Pull up the documentation for rnorm() now.
  CorrectAnswer: ?rnorm
  AnswerTests: omnitest('?rnorm')
  Hint: Type ?rnorm to view its help file.

- Class: cmd_question
  Output: The standard normal distribution has mean 0 and standard deviation 1. As you can see under the 'Usage' section in the documentation, the default values for the 'mean' and 'sd' arguments to rnorm() are 0 and 1, respectively. Thus, rnorm(10) will generate 10 random numbers from a standard normal distribution. Give it a try.
  CorrectAnswer: rnorm(10)
  AnswerTests: omnitest('rnorm(10)')
  Hint: Use rnorm(10) to generate 10 random numbers from a standard normal distribution.

- Class: cmd_question
  Output: Now do the same, except with a mean of 100 and a standard deviation of 25.
  CorrectAnswer: rnorm(10, 100, 25)
  AnswerTests: match_call('rnorm(10, 100, 25)')
  Hint: Use rnorm(10, mean = 100, sd = 25) to generate 10 random numbers from a normal distribution with mean 100 and standard deviation 25.

- Class: text
  Output: Finally, what if we want to simulate 100 *groups* of random numbers, each containing 5 values generated from a Poisson distribution with mean 10? Let's start with one group of 5 numbers, then I'll show you how to repeat the operation 100 times in a convenient and compact way.

- Class: cmd_question
  Output: Generate 5 random values from a Poisson distribution with mean 10. Check out the documentation for rpois() if you need help.
  CorrectAnswer: rpois(5, 10)
  AnswerTests: match_call('rpois(5, 10)')
  Hint: Use rpois(5, 10) to generate 5 random numbers from a Poisson distribution with mean 10.

- Class: cmd_question
  Output: Now use replicate(100, rpois(5, 10)) to perform this operation 100 times. Store the result in a new variable called my_pois.
  CorrectAnswer: my_pois <- replicate(100, rpois(5, 10))
  AnswerTests: match_call('my_pois <- replicate(100, rpois(5, 10))')
  Hint: my_pois <- replicate(100, rpois(5, 10)) will repeat the operation 100 times and store the result.

- Class: cmd_question
  Output: Take a look at the contents of my_pois.
  CorrectAnswer: my_pois
  AnswerTests: omnitest('my_pois')
  Hint: Print the contents of my_pois to the console.

- Class: cmd_question
  Output: replicate() created a matrix, each column of which contains 5 random numbers generated from a Poisson distribution with mean 10. Now we can find the mean of each column in my_pois using the colMeans() function. Store the result in a variable called cm.
  CorrectAnswer: cm <- colMeans(my_pois)
  AnswerTests: omnitest('cm <- colMeans(my_pois)')
  Hint: Use cm <- colMeans(my_pois) to create a vector of column means, storing the result in cm.

- Class: cmd_question
  Output: And let's take a look at the distribution of our column means by plotting a histogram with hist(cm).
  CorrectAnswer: hist(cm)
  AnswerTests: omnitest('hist(cm)')
  Hint: hist(cm) will give you a histogram of column means.

- Class: text
  Output: Looks like our column means are almost normally distributed, right? That's the Central Limit Theorem at work, but that's a lesson for another day!

- Class: text
  Output: All of the standard probability distributions are built into R, including exponential (rexp()), chi-squared (rchisq()), gamma (rgamma()), .... Well, you see the pattern.

- Class: text
  Output: Simulation is practically a field of its own and we've only skimmed the surface of what's possible. I encourage you to explore these and other functions further on your own.
