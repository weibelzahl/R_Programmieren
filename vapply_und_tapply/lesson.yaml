- Class: meta
  Course: R Programming
  Lesson: vapply and tapply
  Author: Nick Carchedi
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.11

- Class: text
  Output: "In der letzten Übung haben Sie die beiden grundlegendsten '*apply-Funktionen' kennen gelernt: lapply() und sapply(). Beide nehmen eine Liste als Argument an, wenden eine Funktion auf jedes Element der Liste an und geben dann gebündelt das Ergebnis aus. lapply() gibt immer eine Liste aus, sapply() hingegen versucht das Ergebnis zu vereinfachen."

- Class: text
  Output: In dieser Übung werden Sie lernen, wie Sie die Funktionen vapply() und tapply() nutzen, die beide einem sehr spezifischen Zweck in der "Split-Apply-Combine methodology" dienen. Wir werden wieder den Datensatz "Flags" benutzen.

- Class: text
  Output: 'Der Datensatz "Flags" der "UCI Machine Learning Repository" enthält Details verschiedener Nationen und Ihrer Flaggen. Mehr Informationen (in englischer Sprache) finden Sie auf folgender Website: http://archive.ics.uci.edu/ml/datasets/Flags'

- Class: text
  Output: Die Daten sind in einer Variable namens "flags" gespeichert. Wenn es einige Zeit her ist, dass Sie die 'lapply und sapply' Übung abgeschlossen haben, sollten Sie sich erneut mit Hilfe von Funktionen wie dim(), head(), str() und summary() mit den Daten vertraut machen, sobald die Eingabeaufforderung erscheint (>). Sie können auch viewinfo() eintippen, um eine Dokumentation über den Datensatz aufzurufen. Fangen wir an!

- Class: cmd_question
  Output: Wie Sie in der letzten Übung gesehen haben, gibt die Funktion unique() einen Vektor aller in einem Objekt vorkommenden voneinander verschiedenen Werte bzw. Ausprägungen aus. Deswegen ist das Ergebnis von sapply(flags, unique) eine Liste, die für jede Spalte des Datensatzes einen Vektor enthält, in dem die in der jeweiligen Spalte vorkommenden voneinander verschiedenen Werte aufgeführt sind. Schauen Sie sich das Ergebnis dieses Befehls jetzt noch einmal an.
  CorrectAnswer: sapply(flags, unique)
  AnswerTests: omnitest(correctExpr='sapply(flags, unique)')
  Hint: Tippen Sie sapply(flags, unique) in die Konsole.

- Class: text
  Output: Nehmen wir an, Sie haben vergessen, was die Funktion unique() bewirkt und fälschlicherweise gedacht, sie würde Ihnen die Anzahl der einmaligen Werte, die in einem Objekt enthalten sind, ausgeben. Dann würden Sie erwartet haben, dass das Ergebnis von sapply(flags, unique) ein numerischer Vektor ist, da jedes Element der Liste eine einzelne Zahl wäre und sapply() diese Liste dann zu einem Vektor vereinfachen könnte.

- Class: text
  Output: Wenn Sie interaktiv arbeiten, ist das kein großes Problem, da Sie das Ergebnis sofort sehen und schnell Ihren Fehler erkennen werden. Wenn Sie jedoch nicht interaktiv arbeiten (z.B. wenn Sie eine eigene Funktion schreiben), kann ein Missverständnis unentdeckt bleiben und zu fehlerhaften späteren Ergebnisse führen. Deswegen könnten Sie den Wunsch haben, vorsichtiger zu sein, und dies ist die Stelle, an der vapply() nützlich ist. 

- Class: text
  Output: sapply() versucht das richtige Format zu 'erraten', vapply() hingegen erlaubt es Ihnen, das Format explizit zu spezifizieren. Wenn das Ergebnis nicht mit dem von Ihnen angegebenen Format übereinstimmt, wir vapply() eine Fehlermeldung ausgeben, die die Operation stoppt. Das kann bedeutsame Probleme in Ihrem Kode verhindern, die daran liegen, dass Sie unerwartete Werte als Ergebnis von sapply() erhalten.

- Class: cmd_question
  Output: Probieren Sie den Befehl vapply(flags, unique, numeric(1)) aus, der besagt, dass Sie erwarten, dass jedes Element des Ergebnisses ein numerischer Vektor der Länge 1 ist. Da dies nicht der Fall ist, werden Sie eine FEHLERMELDUNG erhalten! Tippen Sie ok(), nachdem Sie die Fehlermeldung erhalten haben, um mit der nächsten Frage fortzufahren. 
  CorrectAnswer: ok()
  AnswerTests: omnitest(correctExpr="ok()")
  Hint: Tippen Sie vapply(flags, unique, numeric(1)) und danach ok() um mit der nächsten Frage fortzufahren.

- Class: cmd_question
  Output: In der letzten Übung haben wir gesehen, dass sapply(flags, class) uns einen 'character vector' ausgibt, der für jede Spalte (Variable) des Datensatzes die entsprechende Kategorie angibt. Schauen Sie sich das Ergebnis erneut an.
  CorrectAnswer: sapply(flags, class)
  AnswerTests: omnitest(correctExpr="sapply(flags, class)")
  Hint: Tippen Sie sapply(flags, class) um einen 'character vector' der Kategorien, in die die jeweiligen Spalten fallen, zu erhalten.

- Class: cmd_question
  Output: Wenn wir explizit das erwartete Format des Ergebnisses angeben möchten, können wir den Befehl vapply(flags, class, character(1)) nutzen. Das Argument 'character(1)' sagt R, dass wir erwarten, dass die Funktion class uns für jede Spalte, auf die sie angewendet wird, einen 'character vector' der Länge 1 ausgibt. Probieren Sie den Befehl jetzt aus.
  CorrectAnswer: vapply(flags, class, character(1))
  AnswerTests: omnitest(correctExpr="vapply(flags, class, character(1))")
  Hint: Nutzen Sie den Befehl vapply(flags, class, character(1)) um einen 'character vector' der Kategorien der Spalten (Variablen) zu erhalten.

- Class: text
  Output: Beachten Sie, dass - da unsere Erwartung richtig war - die Ergebnisse von vapply() und sapply() identisch sind. Wir erhalten jeweils einen 'character vector' der Kategorien der Spalten.

- Class: text
  Output: Sie denken, wahrscheinlich, dass vapply() "sicherer" als sapply() ist, da es Sie zwingt, das erwartete Format anzugeben, anstatt R "raten" zu lassen. Zudem ist die Ausführung des Befehls vapply() bei großen Datensätzen oft schneller als die des Befehls sapply(). Wenn Sie interaktiv arbeiten, spart Ihnen sapply() allerdings einiges an Tipparbeit und wird in der Regel gut genug sein.

- Class: text
  Output: 
  As a data analyst, you'll often wish to split your data up into groups based on the value of some variable, then apply a function to the members of each group. The next function we'll look at, tapply(), does exactly that.

- Class: cmd_question
  Output: Use ?tapply to pull up the documentation.
  CorrectAnswer: ?tapply
  AnswerTests: any_of_exprs('?tapply', 'help(tapply)')
  Hint: Pull up the help file with ?tapply.

- Class: cmd_question
  Output: The 'landmass' variable in our dataset takes on integer values between 1 and 6, each of which represents a different part of the world. Use table(flags$landmass) to see how many flags/countries fall into each group.
  CorrectAnswer: table(flags$landmass)
  AnswerTests: omnitest(correctExpr="table(flags$landmass)")
  Hint: Use table(flags$landmass) to see how many flags/countries fall into each group.

- Class: cmd_question
  Output: The 'animate' variable in our dataset takes the value 1 if a country's flag contains an animate image (e.g. an eagle, a tree, a human hand) and 0 otherwise. Use table(flags$animate) to see how many flags contain an animate image.
  CorrectAnswer: table(flags$animate)
  AnswerTests: omnitest(correctExpr="table(flags$animate)")
  Hint: Use table(flags$animate) to see how many flags contain an animate image.

- Class: text
  Output: This tells us that 39 flags contain an animate object (animate = 1) and 155 do not (animate = 0).

- Class: cmd_question
  Output: If you take the arithmetic mean of a bunch of 0s and 1s, you get the proportion of 1s. Use tapply(flags$animate, flags$landmass, mean) to apply the mean function to the 'animate' variable separately for each of the six landmass groups, thus giving us the proportion of flags containing an animate image WITHIN each landmass group.
  CorrectAnswer: tapply(flags$animate, flags$landmass, mean)
  AnswerTests: omnitest(correctExpr="tapply(flags$animate, flags$landmass, mean)")
  Hint: tapply(flags$animate, flags$landmass, mean) will tell us the proportion of flags containing an animate image within each landmass group.

- Class: text
  Output: The first landmass group (landmass = 1) corresponds to North America and contains the highest proportion of flags with an animate image (0.4194).

- Class: cmd_question
  Output: Similarly, we can look at a summary of population values (in round millions) for countries with and without the color red on their flag with tapply(flags$population, flags$red, summary).
  CorrectAnswer: tapply(flags$population, flags$red, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$red, summary)")
  Hint: You can see a summary of populations for countries with and without the color red on their flag with tapply(flags$population, flags$red, summary).

- Class: mult_question  
  Output: What is the median population (in millions) for countries *without* the color red on their flag?
  AnswerChoices: 9.0; 4.0; 27.6; 3.0; 22.1; 0.0
  CorrectAnswer: 3.0
  AnswerTests: omnitest(correctVal= '3.0')
  Hint: Use your result from the last question. Recall that red = 0 means that the color red is NOT present on a countries flag.

- Class: cmd_question
  Output: Lastly, use the same approach to look at a summary of population values for each of the six landmasses.
  CorrectAnswer: tapply(flags$population, flags$landmass, summary)
  AnswerTests: omnitest(correctExpr="tapply(flags$population, flags$landmass, summary)")
  Hint: "You can see a summary of populations for each of the six landmasses by calling tapply() with three arguments: flags$population, flags$landmass, and summary."

- Class: mult_question  
  Output: What is the maximum population (in millions) for the fourth landmass group (Africa)?
  AnswerChoices: 56.00; 1010.0; 119.0; 5.00; 157.00
  CorrectAnswer: 56.00
  AnswerTests: omnitest(correctVal= '56.00')
  Hint: Use your result from the last question.

- Class: text  
  Output: In this lesson, you learned how to use vapply() as a safer alternative to sapply(), which is most helpful when writing your own functions. You also learned how to use tapply() to split your data into groups based on the value of some variable, then apply a function to each group. These functions will come in handy on your quest to become a better data analyst.
